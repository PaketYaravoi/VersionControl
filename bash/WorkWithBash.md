#### Получение справочной информации:

* git help (команда)
* git (команда) --help
* man git-(команда)
К примеру справка по команде "config" открывается так:
git help config


#### Работа с конфигами:

* git config --global(local) user.name "userName" - имя пользователя машина на котором проект(либо имя владельца директории)
local/global на весь ком-ер или дерикторию в которой мы находимся

* git config --global(local) user.email "userEmail" - почта правообладателя ветки master*
* git config --list -список всех конфигураций в текущей директории

* Для того чтобы исправить настройки пользователя необходимо ввести команду git config --global(local) настройки пользователя ЕЩЕ РАЗ , тогда настройки перезапишутся


#### Работа с дерикториями:

* git init - инициализация директории(создание папки версионности .git). При создании папки , создается и ветка master наша изначальная ветка для работы с версиями
* git status - позволяет проверить изменения и расположнеие в ветках
* git status -s; git status --short
Запустив команду git status -s или git status --short, вы получите упрощенный вариант вывода. 


* mkdir - создать новую папку (mkdir название(пробелы не учитываюстя))
* cd ../.. -  команда "перейти в корень"  
* cd 'название папки' - (ковычки нужны если в названии папки используются пробелы) переход в папку дальше (необходимо делать переход из текущей в следующюи иначе писать весь путь целиком). В разных терминалах отрабатывает по разному, где то ковычки будут нужны где то нет, где то потребуеся знак "/"
* cd ../ - переход на уровень папок выше.

#### Работа с файлами:

* touch имя.расширение  - создать файл в текущей папке
* echo "ввод инф" > nameFile.(расширение) - заполнить первую строку в указанном файле. 
* rm название файла - удалить файл из рабочей папки.

* git rm (название файла) - следующая команда git rm индексирует удаление файла(полностью удалить и не следить(IL))
При очередной фиксации изменений файл пропадет и перстает отслеживаться. Если же вы отредактировали файл и уже добавили его в облость индексирования, сделует воспользоваться пораметром __*-f*__, инициирующим принудительное удаление 
Иногда требутся оставить файл в рабочей папке удалив его из облости индексирования. Другими словами , оставить файл но перестать за ним следить! В этос случае на помощь приходит  команда :
* git rm --cached (namefails)
Команду git rm можно передавать в качестве аргументов файлы, папки и глобальные паттерны. То есть можно писать :
$ git rm log/\*.log - Обратите внимание на обратный слеш (\) перед символом(*). Он необходим потомучто Git добавляет собственные расширения к расширениям имен файлов оболочки
В такой форме команда удаляет все файлы с расширением .log из папки log/.
Или вы можете написать :
$ git rm \~ Эта команда удалит все файлы , имена которых заканчивается на "~"

* cat nameFile.(расширение) - посмотреть что написанно в строках файла.  
* ls - отображение списка коталогов и документов в "чистом" формате.Без деталей такие как(тип, размер, дата и время , ссылки, разрешениия и тд)
* ls -a - отображает все содержимое директории, включая скрытые файла (их имена начинаются с точки)

### Примечания 

при работе с директориями, "cd", наименование директорий очень чувствительны к  регистру.
Например, даже не смотря что путь у вас прописан керилецей(русский или другой любой язык) - правило для входа на рабочий стол или файлам находящемся на самом локальном диске - ввод директории (или пути(системного)) вводиться на _**английском языке**_

При работе с папками пользователя которые не редко могут подписанные на руском()родном языке - необходимо выделять наз-е папки кавычками 'мопя папка' -в зависимости от терминала , иногда ковычки не нужны, а иногда необходимо ставить знак "\ или /"


#### Работа с версионностью:

Файлы в Git могут находиться в трех основных состояниях:
1. __*Зафиксированным*__ - (committed) состояние озночает, что данные надежно сохранены в локальной базе.
2. __*Модифицированными*__ - (modified) - состояние означает , что изменения уже внесены в файл, но пока не зафиксированы в базе данных
3. __*Индексированными*__ (staged) -состояние означает, что вы пометили текущую версию модифицированного файла как предназначенную для следующей фиксации.

* git log Посмотреть текущее состояние и последние 3 лога(коммиты).
* git log --graph схематичное отоброжение логов, веток
* git log --oneline - короткий в одну строку

* git branch Посмотреть колличество веток, их имена, а также нахождение на текущей ветке "*" 
* git branch -m - переименновать текущую ветку на которой вы находитесь например с "reserv" на "new"
* git branch -d название ветки - удалить ветку
* git checkout имя ветки(коммита) Перейти на другую ветку() 

* git merge имя ветки -  слить ветки (взять данные из указынной ветки и перетащить в текущую)
* git reflog - история всех изменений в текущем репозиториип

 * Для того чтобы изменить текст коммита  можно открыть файл в дериктории .git папка logs > HEAD(Через блокнот, и меняем текст сообщения нужного нам лога)

##### * git reset - используется для отмены изменений в рабочей директории и области индексирования (staging area) до определенного коммита в Git. Эта команда имеет несколько опций, которые позволяют указать, какие изменения вы хотите отменить и какие действия сделать с изменениями после указанного коммита.

##### Вот некоторые из основных опций git reset:

##### --soft: Отменяет изменения, сделанные после указанного коммита, но оставляет изменения в рабочей директории и области индексирования. Это позволяет вам пересоздать коммиты с изменениями, которые были отменены.

##### --mixed (по умолчанию): Отменяет изменения в области индексирования, но не затрагивает рабочую директорию. Это означает, что изменения вернутся в рабочую директорию, но не будут включены в следующий коммит. (можно изменить и коммит и робочую облость модифицированную, но но они не будут ни проиндексированными ни зафиксированными )

##### --hard: Отменяет изменения в области индексирования и рабочей директории, возвращая ваш репозиторий к состоянию, какое он было на указанном коммите. Эта опция удаляет все изменения, сделанные после указанного коммита, включая неотслеживаемые файлы.


##### * git reset "номер коммита" - откатить проект на версию указанного коммита(осторожно(при переходе на указанный коммит информация из текс редактора перенесется , но она не будет сохранена если ее не сохранить она будет утеряна))  ..

##### __*Reset отлично работает на локальных ветках , в локальных реп-ях. Но этот метод переписывания истории не сработает на удаленных ветках , которые используют другие поль-ли.*

* Чтобы отменить изменения и поделиться отмененными изменениями с остальными , надо использовать комамнду _*git revert*_. 

* git revert(name/HEAD~;^) - откатить историю репозитория на указанный уровень (коммит или родитя или родителя прородителя...)
* после _*revert*_ можно сделать _*push*_ и поделиться изменениями с остальными. 
 нельзя. Выполнять команду очень осторожно.(только если есть ветки с сохранением на бекапп)
 

Если файлы небыли переписаны или удалены, то изменения просто перенесутся в текущую ветку как "старое + новое", но если мы удалим в прежней версии информацию или заменим ее то при слиянии таких веток будет возникать *конфилкт*
_*конфликт -процес при слияниях веток рабочего проекта в котором необходимо указать правила текущего слияния. Конфликт можно решать несколькими путями принимать значения из версии текущей ветки и наоборот но, эффективней всего редактировать вручную и делать новый коммит после фикса(оставляем то что нужно, остальное удаляем , делаем лог)*_

Елси есть конфликт, значит есть разница между версиями, точки перехода на новую ветку, версию строки на новой ветке а также изменения после входа на другую ветку в ветке master(главная ветка для слияния.
Иными словами: елси разница между строками в ветке мастер есть и резервновй ветке, при слиянии изменения войдут из ветки резерв. Для конфликта нужно 3 различия! в ветке мастек, резерв , а также разница между версиями мастер ветки в точке перехода и после нее.

* git rebase - объеденение веток

Еще одна команда объеденения изменений в веткак _*git rebasing*_. При ребейзже git по сути копирует набор коммитов и перености их в другое место. С помощью этой команды можно делать чистые и кравсивые линейные последовательности коммитов. История коммитов будет чище если вы примените *_rebase_*

* "HEAD" -это символическое имя текущего выбранного коммита -это, по сути, тот коммит, над которым мы в данноый момент работаем. HEAD всегда указывает на последний коммти из вашего локального дерева. Большинство команд Git , изменяющих рабочее дерево, начнут с изменения HEAD. Обычно HEAD указывает на имя ветки (например , bugfix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD. 

* Перемещение по коммитам:
Как мы уже говорили, указание на коммит при помощи его хеша - не самый удобный способ , поэтому Git поддерживает отностительные ссылки и они прекрасныы! С относительными ссылками можно начать с какого-либо удобного места ( например с ветки bugFix или от HEAD ) и двигаться от него. _Относительные ссылки_ - мощный инструмент , вот два простых способа использования:

*  git checkout (name)^(alt94) - перемещение на один коммит назад

Предположим , нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать ^ несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (~)
К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти. 

* git checkout (name)~ <num>(0126(тильда)) - переместиться на на несколько родительских коммитов назад.

* Одна из наиболее распространненых целей , для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции "-f". Например, команда:
* git branch -f main HEAD~3 - переместит (принудительно) ветку main на три родителя назад от HEAD(точки, коммита с которым мы работаем в данное время)

Есть много путей для отмены изменений в Git. Так же как и коммит , отмена изменений в git возможна и на низком уровне (Добавление в коммит отдельных файлов и наборов строк), и на высоком (как зименения реально отменяются). 
Есть 2 основных способа отмены изменений в Git: первый - это git reset, а второй - git revert.

#### Работа с файлами и директорией: 

* cat info.md - где "info.md" это имя файла (поевляется код или информация с элементами разметки)
* git add имя файла - добавить изменения в текущий файл
* git add . -добавить все изменения
* git commit -m"masage" - прописать комментарий к сохранения и само сохранение
* команду можно записывать несколькими способами : (git add .; git commit -m"masage" в одну строку)- еффективна для работы с несколькими файлами, где нужно указать имя файла;    (git commit -a -m"masage")- для работы с одним файлом.
* git diff - посмотреть разницу проекта текущего с последним коммитом
Чтобы посмотреть что из проиндексированного войдет вледующий коммит , воспользуетсь командй 
* git diff --staget - Команда сравнивает индексированыые изменения с содержанием последней зафиксированной версии
* git diff --cached - Покажет проиндексированные изменения


#### Работа с удаленными репозиториями:

* git remote add.  - Добавление удалленного репозитория к существующему локальному.
* git remote -v - Эта команда отобразит текущий удаленный URL-адрес как для операций выборки, так и для операций отправки. Например, если ваш проект размещен на GitHub, вы можете увидеть вывод, подобный этому.
* git remote set-url origin (ссылка на удаленный реп) - заменить URL-адрес  

### Примечания
